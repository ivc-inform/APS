<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <title>RESTHandler (SmartClient Enterprise Server API 11.1p (2017-07-03))</title> <meta name="date" content="2017-07-03"> <link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> <script type="text/javascript" src="../../../script.js"></script> </head> <body> <script type="text/javascript">try{if(location.href.indexOf("is-external=true")==-1){parent.document.title="RESTHandler (SmartClient Enterprise Server API 11.1p (2017-07-03))"}}catch(err){}var methods={i0:10};var tabs={65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};var altColor="altColor";var rowColor="rowColor";var tableTab="tableTab";var activeTableTab="activeTableTab";</script> <noscript> <div>JavaScript is disabled on your browser.</div> </noscript> <div class="topNav"><a name="navbar.top"> </a> <div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div> <a name="navbar.top.firstrow"> </a> <ul class="navList" title="Navigation"> <li><a href="../../../overview-summary.html">Overview</a></li> <li><a href="package-summary.html">Package</a></li> <li class="navBarCell1Rev">Class</li> <li><a href="package-tree.html">Tree</a></li> <li><a href="../../../deprecated-list.html">Deprecated</a></li> <li><a href="../../../index-all.html">Index</a></li> <li><a href="../../../help-doc.html">Help</a></li> </ul> </div> <div class="subNav"> <ul class="navList"> <li><a href="../../../com/isomorphic/servlet/RequestContext.html" title="class in com.isomorphic.servlet"><span class="typeNameLink">Prev&nbsp;Class</span></a></li> <li><a href="../../../com/isomorphic/servlet/ScreenLoaderServlet.html" title="class in com.isomorphic.servlet"><span class="typeNameLink">Next&nbsp;Class</span></a></li> </ul> <ul class="navList"> <li><a href="../../../index.html?com/isomorphic/servlet/RESTHandler.html" target="_top">Frames</a></li> <li><a href="RESTHandler.html" target="_top">No&nbsp;Frames</a></li> </ul> <ul class="navList" id="allclasses_navbar_top"> <li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li> </ul> <div> <script type="text/javascript">allClassesLink=document.getElementById("allclasses_navbar_top");if(window==top){allClassesLink.style.display="block"}else{allClassesLink.style.display="none"};</script> </div> <div> <ul class="subNavList"> <li>Summary:&nbsp;</li> <li>Nested&nbsp;|&nbsp;</li> <li>Field&nbsp;|&nbsp;</li> <li>Constr&nbsp;|&nbsp;</li> <li><a href="#method.summary">Method</a></li> </ul> <ul class="subNavList"> <li>Detail:&nbsp;</li> <li>Field&nbsp;|&nbsp;</li> <li>Constr&nbsp;|&nbsp;</li> <li><a href="#method.detail">Method</a></li> </ul> </div> <a name="skip.navbar.top"> </a></div> <div class="header"> <div class="subTitle">com.isomorphic.servlet</div> <h2 title="Class RESTHandler" class="title">Class RESTHandler</h2> </div> <div class="contentContainer"> <ul class="inheritance"> <li>java.lang.Object</li> <li> <ul class="inheritance"> <li>javax.servlet.GenericServlet</li> <li> <ul class="inheritance"> <li>javax.servlet.http.HttpServlet</li> <li> <ul class="inheritance"> <li><a href="../../../com/isomorphic/servlet/BaseServlet.html" title="class in com.isomorphic.servlet">com.isomorphic.servlet.BaseServlet</a></li> <li> <ul class="inheritance"> <li>com.isomorphic.servlet.RESTHandler</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> <div class="description"> <ul class="blockList"> <li class="blockList"> <hr> <br> <pre>public class <span class="typeNameLabel">RESTHandler</span>
extends <a href="../../../com/isomorphic/servlet/BaseServlet.html" title="class in com.isomorphic.servlet">BaseServlet</a></pre> <div class="block">This servlet handles built-in SmartClient datasource requests sent from REST clients. The <code>RestDataSource</code> provided with SmartClient is such a client, as is SmartGWT.mobile, but this handler will work with any REST client that encodes its data as JSON or XML, sends its requests as POST messages and conforms to the REST transfer protocol described in the client-side documentation for <code>RestDataSource</code>. Note that you <b>must</b> read these client-side documents in order to understand how to properly format a REST request for processing by this servlet. <p> By default JSON responses will be wrapped into special markers so that code is not directly executable outside of your application. This is a preventive measure against <a href='http://forums.smartclient.com/showthread.php?t=235'>javascript hijacking</a>.<p/> The servlet accepts parameter "wrapJSONResponses": <code>true</code> - wrap JSON responses; <code>false</code> - send plain JSON reponses. The parameter can be set in your web.xml file either as a context parameter (for all servlets) or as a servlet initialization parameter. <p> If JSON wrapping is on, you can also set the prefix and suffix strings that we use to wrap responses. Again, you do this by setting the parameters "jsonPrefix" and "jsonSuffix" in your web.xml file, either as a context parameter (for all servlets) or as a servlet initialization parameter. If these parameters are not set in web.xml, they default as follows:<br><br> &nbsp;&nbsp;<b>jsonPrefix: </b>"&lt;SCRIPT&gt;//'\"]]&gt;&gt;isc_JSONResponseStart&gt;&gt;"<br> &nbsp;&nbsp;<b>jsonSuffix: </b>"//isc_JSONResponseEnd" <p> Note that these parameters can be overridden at the DataSource level, by providing a <code>.ds.xml</code> file for the DataSource, and specifying <code>jsonPrefix</code> and <code>jsonSuffix</code> in there. <p> <b>NOTE:</b> The default settings shown above are also the defaults used by the client-side RestDataSource. If you choose to change the default prefix and/or suffix strings returned by the server, you must obviously also change the strings that the client expects to see. If you are using RestDataSource, you do this by overriding the <code>jsonPrefix</code> and <code>jsonSuffix</code> properties. See the client-side documentation for details. <p> The servlet also accepts parameter "defaultDataFormat". This governs whether we expect requests to be encoded as XML or JSON, if no explicit dataFormat is provided with the request. Note that the dataFormat <b>is</b> explicitly sent with every request if you are using the Isomorphic <code>RestDataSource</code> (see below), so this parameter has no effect in that case; it is only used when no dataFormat is provided with the request, as would be the case if you are integrating with a third-party REST client. <p> If you do not specify a defaultDataFormat, "xml" is assumed. <p> The servlet also accepts parameter "dynamicDataFormatParamName". This governs the name of the dataFormat parameter we look for in incoming requests (as described above in the paragraph about "defaultDataFormat"). If you wish to send the dataFormat to use with each client request, you send an HTTP parameter with this name in the request, with a value of "xml" or "json". By default, the "dynamicDataFormatParamName" is the value used by the SmartClient RestDataSource: "isc_dataFormat". <p> NOTE: This servlet is configured to automatically set character encoding on requests and responses to UTF-8. If you wish to force a different encoding, you can do so by specifying the <code>init-param</code> "encoding" in your web.xml file, as shown in the example below. If you wish to switch off explicit encoding altogether, use the <code>init-param</code> to set a value of "none". <p> Please see the client-side documentation on Internationalization for a discussion of why this procedure is necessary. <p> This snippet shows how you might change your <code>web.xml</code> file to configure the <code>RESTHandler</code> servlet:<pre>
   &lt;servlet&gt;
       &lt;servlet-name&gt;RESTHandler&lt;/servlet-name&gt;
       &lt;servlet-class&gt;com.isomorphic.servlet.RESTHandler&lt;/servlet-class&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;defaultDataFormat&lt;/param-name&gt;
           &lt;param-value&gt;json&lt;/param-value&gt;
       &lt;/init-param&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;dynamicDataFormatParamName&lt;/param-name&gt;
           &lt;param-value&gt;theDataFormat&lt;/param-value&gt;
       &lt;/init-param&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;wrapJSONResponses&lt;/param-name&gt;
           &lt;param-value&gt;false&lt;/param-value&gt;
       &lt;/init-param&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;encoding&lt;/param-name&gt;
           &lt;param-value&gt;some-other-encoding&lt;/param-value&gt;
       &lt;/init-param&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
       &lt;servlet-name&gt;RESTHandler&lt;/servlet-name&gt;
       &lt;url-pattern&gt;/restapi/&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;</pre> <P> <b>Raw REST Mode</b> <P> RESTHandler also offers a "raw" REST mode in which the DataSource name and primary key values appear in the request URI, with simplified responses. This "raw mode" may be appropriate for automated systems that need to query or update DataSource data in a simplified manner. <b>Using "raw mode" for a SmartClient or SmartGWT browser-based UI is always, <i>always</i> wrong.</b> It will create additional work while crippling your UI's capabilities and also creating performance problems. <P> A raw REST mode HTTP request consists of the URI that you provide (including any params), the HTTP verb, and any params (key/value pairs) specified as posted data. The HTTP response format - either XML or JSON - is determined as discussed above by the servlet parameter <code>defaultDataFormat</code> or the request parameter named by the servlet parameter <code>dynamicDataFormatParamName</code>, <b>but the default for raw REST mode is JSON</b>, unlike standard REST mode. The HTTP response status will reflect the success (2XX) or failure (4XX/5XX) of the request, and a failure will contain one or more error messages. For more details on status codes, see <a href='http://www.restapitutorial.com/lessons/httpmethods.html'>HTTP methods</a>. <P> <b>URI Interpretation</b> <P> The basic raw REST mode URI syntax is: <pre>
     isomorphic/RESTHandler/&lt;DataSource name&gt;[/&lt;primary key value&gt;]</pre> where the DataSource name must always be provided, but a primary key value is optional. Additional field/value pairs may be provided as query parameters or posted data, including the primary key if the longer syntax is not used. <P> HTTP verbs are handled as follows:<ul> <li>An HTTP GET performs a fetch, with any query params beyond the primary key interpreted as simple criteria. <li>An HTTP DELETE performs a remove, with any query params or posted data beyond the primary key interpreted as simple criteria. <li>An HTTP POST performs an add, with both query params and posted data providing the record field content. <li>An HTTP PUT or PATCH performs an update, with both query params and posted data providing the record field content. However a PUT with no primary key value(s) performs an add, but a PATCH with no primary value values(s) performs a multi-row update, subject to the currently configured <code>allowMultiUpdate</code> settings for updates on that DataSource.</ul> <P> For example, to fetch the record with primary key value <code>5</code> from <code>countryDS</code> DataSource, you would send an HTTP GET with URI <b><code>isomorphic/RESTHandler/countryDS/5</code></b>, and to add a new country record to <code>countryDS</code> DataSource, which has an autogenerated sequence primary key, you would send an HTTP POST with URI <b><code>isomorphic/RESTHandler/countryDS</code></b> and all the record field content as the POSTED data. (Various POSTED data formats, such as application/x-www-form-urlencoded "form data" are supported by the servlet.) <P> <b>Singular vs. Array Response Format</b> <P> For both XML and JSON reply formats, whether you receive a singular or array reply is determined by the HTTP request type:<ul> <li>Singular responses are sent for adds, fetches that supply the primary key value as a path segment (not as a query param or POSTED data), and updates or removes that specify the primary key either as param(s) or as a path segment. <li>Array responses are always generated for any fetch which doesn't specify the primary key as a path segment, or any update or remove request that doesn't specify a primary key.</ul> <P> So for example singular responses look like: <pre>{ fieldName : fieldValue, fieldName2: fieldValue2}</pre> for JSON, and <pre>
 &lt;record&gt;
     &lt;fieldName&gt;fieldValue&lt;/fieldName&gt;
     &lt;fieldName2&gt;fieldValue2&lt;/fieldName2&gt;
 &lt;/record&gt;</pre> for XML, whereas array responses look like: <pre>[ { fieldName : fieldValue, fieldName2: fieldValue2}, ... ]</pre> for JSON, and <pre>
 &lt;data&gt;
     &lt;record&gt;
         &lt;fieldName&gt;fieldValue&lt;/fieldName&gt;
         &lt;fieldName2&gt;fieldValue2&lt;/fieldName2&gt;
     &lt;/record&gt;
     &lt;record&gt;
         &lt;fieldName&gt;fieldValue&lt;/fieldName&gt;
         &lt;fieldName2&gt;fieldValue2&lt;/fieldName2&gt;
     &lt;/record&gt;
 &lt;/data&gt;
</pre> for XML. Note that, regardless of the above, if a request returns no results, it will be show up as an empty HTTP response with status 204 - "no content". <P> <b>Error Response Format</b> <P> When an error HTTP status (4XX or 5XX) is returned from the server, there will be an error object included. It will contain an error code and an array of error messages (even if there's just one message). For JSON, it might look like: <pre>{ code: -1, messages: ["fatal error: cannot find DataSource 'fred'"]}</pre> and for XML is might look like: <pre>
 &lt;error&gt;
     &lt;code&gt;-1&lt;/code&gt;
     &lt;messages&gt;
         &lt;message&gt;"fatal error: cannot find DataSource 'fred'"]}&lt;/message&gt;
     &lt;/messages&gt;
 &lt;/error&gt;</pre> <P> <b>Expanded Raw REST mode URI Syntax</b> <P> In addition to the URI syntax discussed above, raw REST mode also acecpts HTTP requests with the syntax: <pre>
     isomorphic/RESTHandler/&lt;operation&gt;[/&lt;operation ID&gt;]</pre> where the operation is one of "add", "remove", "update", or "fetch", and the operation ID (specifying the <code>operationId</code>, is optional. For example, the URI <b><code>isomorphic/RESTHandler/fetch/foobar</code></b> specifies that a "fetch" is to be performed with the <code>operationId</code> of "foobar". Note that support for this syntax means that you must not use those four operation names as primary key values for your DataSource. <P> <b>Hybrid Raw REST mode</b> <P> Hybrid mode allows you to send the HTTP requests as you otherwise would as described above, but receive the responses as normal RestDataSource DSResponses. To use hybrid mode, specify <code>hybridMode</code> as a servlet initialization param or query param in the HTTP request. Note that in hybrid mode, the following properties are supported as query params or posted data:<ul> <li><code>criteria</code> - must be valid JSON for simple or AdvancedCriteria <li><code>sortBy</code> - must be either a string or a valid JSON array of simple <code>sortBy</code> string specifiers <li><code>startRow</code> and <code>endRow</code> - as numbers <li><code>textMatchStyle</code> - as a string </ul></div> <dl> <dt><span class="seeLabel">See Also:</span></dt> <dd><a href="../../../serialized-form.html#com.isomorphic.servlet.RESTHandler">Serialized Form</a></dd> </dl> </li> </ul> </div> <div class="summary"> <ul class="blockList"> <li class="blockList"> <ul class="blockList"> <li class="blockList"><a name="method.summary"> </a> <h3>Method Summary</h3> <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation"> <caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption> <tr> <th class="colFirst" scope="col">Modifier and Type</th> <th class="colLast" scope="col">Method and Description</th> </tr> <tr id="i0" class="altColor"> <td class="colFirst"><code>void</code></td> <td class="colLast"><code><span class="memberNameLink"><a href="../../../com/isomorphic/servlet/RESTHandler.html#processRequest-javax.servlet.http.HttpServletRequest-javax.servlet.http.HttpServletResponse-">processRequest</a></span>(javax.servlet.http.HttpServletRequest&nbsp;request, javax.servlet.http.HttpServletResponse&nbsp;response)</code> <div class="block">Servlet entry point to process the request.</div> </td> </tr> </table> </li> </ul> </li> </ul> </div> <div class="details"> <ul class="blockList"> <li class="blockList"> <ul class="blockList"> <li class="blockList"><a name="method.detail"> </a> <h3>Method Detail</h3> <a name="processRequest-javax.servlet.http.HttpServletRequest-javax.servlet.http.HttpServletResponse-"> </a> <ul class="blockListLast"> <li class="blockList"> <h4>processRequest</h4> <pre>public&nbsp;void&nbsp;processRequest(javax.servlet.http.HttpServletRequest&nbsp;request,
                           javax.servlet.http.HttpServletResponse&nbsp;response)
                    throws javax.servlet.ServletException,
                           java.io.IOException</pre> <div class="block">Servlet entry point to process the request. Default implementation instantiates an RPCManager, and invokes handleDSRequest() for each DataSource operation encoded in the HTTP request.</div> <dl> <dt><span class="paramLabel">Parameters:</span></dt> <dd><code>request</code> - The HttpServletRequest</dd> <dd><code>response</code> - The HttpServletResponse</dd> <dt><span class="throwsLabel">Throws:</span></dt> <dd><code>javax.servlet.ServletException</code> - As per HttpServlet.service()</dd> <dd><code>java.io.IOException</code> - As per HttpServlet.service()</dd> </dl> </li> </ul> </li> </ul> </li> </ul> </div> </div> <div class="bottomNav"><a name="navbar.bottom"> </a> <div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div> <a name="navbar.bottom.firstrow"> </a> <ul class="navList" title="Navigation"> <li><a href="../../../overview-summary.html">Overview</a></li> <li><a href="package-summary.html">Package</a></li> <li class="navBarCell1Rev">Class</li> <li><a href="package-tree.html">Tree</a></li> <li><a href="../../../deprecated-list.html">Deprecated</a></li> <li><a href="../../../index-all.html">Index</a></li> <li><a href="../../../help-doc.html">Help</a></li> </ul> </div> <div class="subNav"> <ul class="navList"> <li><a href="../../../com/isomorphic/servlet/RequestContext.html" title="class in com.isomorphic.servlet"><span class="typeNameLink">Prev&nbsp;Class</span></a></li> <li><a href="../../../com/isomorphic/servlet/ScreenLoaderServlet.html" title="class in com.isomorphic.servlet"><span class="typeNameLink">Next&nbsp;Class</span></a></li> </ul> <ul class="navList"> <li><a href="../../../index.html?com/isomorphic/servlet/RESTHandler.html" target="_top">Frames</a></li> <li><a href="RESTHandler.html" target="_top">No&nbsp;Frames</a></li> </ul> <ul class="navList" id="allclasses_navbar_bottom"> <li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li> </ul> <div> <script type="text/javascript">allClassesLink=document.getElementById("allclasses_navbar_bottom");if(window==top){allClassesLink.style.display="block"}else{allClassesLink.style.display="none"};</script> </div> <div> <ul class="subNavList"> <li>Summary:&nbsp;</li> <li>Nested&nbsp;|&nbsp;</li> <li>Field&nbsp;|&nbsp;</li> <li>Constr&nbsp;|&nbsp;</li> <li><a href="#method.summary">Method</a></li> </ul> <ul class="subNavList"> <li>Detail:&nbsp;</li> <li>Field&nbsp;|&nbsp;</li> <li>Constr&nbsp;|&nbsp;</li> <li><a href="#method.detail">Method</a></li> </ul> </div> <a name="skip.navbar.bottom"> </a></div> </body> </html>